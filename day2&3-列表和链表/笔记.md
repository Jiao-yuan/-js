### 存储结构 （8）

1. **数组/列表**

数组/列表是一种数据结构，可以存储多个值。每个元素可以通过索引（数字表示数据的数量）进行访问。数据按顺序存储在连续位置的存储器中。由于它们存储在连续的位置，因此可以使用它们的索引来计算内存地址，以便随机访问数据。数组的另一个特点是与链表相比，在特定位置添加或删除数据的成本很高。

![](../img/tao-数组.jpg)

![](../img/tao-连续存储.jpg)

> 数组的特点

1. 可以存储多个值
2. 每个元素可以通过索引访问
3. 按顺序存储在连续位置的存储器中
4. 在特定位置添加或删除数据的成本很高

> 设计列表数据结构

为了设计列表的抽象数据类型，需要给出列表的定义，包括列表应该拥有哪些属性，应该 在列表上执行哪些操作。

属性或方法 | 功能
---|---
listSize（属性）| 列表的元素个数 
pos（属性）| 列表的当前位置 
length（方法）| 返回列表中元素的个数 
clear（方法） | 清空列表中的所有元素 
toString（方法）| 返回列表的字符串形式 
getElement（方法）| 返回当前位置的元素 
insert（方法）|  在现有元素后插入新元素 
append（方法）| 在列表的末尾添加新元素 
remove（方法）| 从列表中删除元素
front（方法）| 将列表的当前位置设移动到第一个元素
end（方法） | 将列表的当前位置移动到最后一个元素 
prev（方法）| 将当前位置后移一位 
next（方法）| 将当前位置前移一位 
currPos（方法）| 返回列表的当前位置 
moveTo（方法） | 将当前位置移动到指定位置

> 迭代器访问列表

使用迭代器，可以不必关心数据的内部存储方式，以实现对列表的遍历。

以下是和使 用数组索引的方式相比，使用迭代器的一些优点:

- 访问列表元素时不必关心底层的数据存储结构。 

- 当为列表添加一个元素时，索引的值就不对了，此时只用更新列表，而不用更新迭代器。

- 可以用不同类型的数据存储方式实现 List 类，迭代器为访问列表里的元素提供了一种 统一的方式。

**迭代器只是用来在列表上随意移动，而不应该和任何为列表增加或删除元素的方法一起 使用。**

-----

2. **链表**

数组不总是组织数据的最佳数据结构,数组在特定位置添加或删除数据的成本很高，**链表** 是数据元素的线性集合, 元素的线性顺序不是由它们在内存中的物理位置给出的。 相反, 每个元素指向下一个元素。它是由一组节点组成的数据结构,这些节点一起,表示序列。

`链表`是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一个节点的引用叫做`链`

![](../img/链表.jpg)

数组元素靠它们的位置进行引用，链表元素则是靠相互之间的关系进行引用，遍历链表，就是跟着
链接，从链表的首元素一直走到尾元素，（但这不包含链表的头节点，头节点常常用来作为
链表的接入点）**链表的尾元素指向一个 null 节点**

链表的实现都在链表最前面有一个特殊节点，叫做头节点

![](../img/链表-header.jpg)

链表中插入一个节点的效率很高。向链表中插入一个节点，需要修改它前面的节点（前
驱），使其指向新加入的节点，而新加入的节点则指向原来前驱指向的节点

![](../img/链表-插入.jpg)


从链表中删除一个元素也很简单。将待删除元素的前驱节点指向待删除元素的后继节点，同时
将待删除元素指向 null，元素就删除成功了

![](../img/链表-删除.jpg)


链表还有其他一些操作，但插入和删除元素最能说明链表为什么如此有用！

链表的一个缺点是访问时间是线性的(而且难以管道化)。更快的访问，如随机访问，是不可行的。与链表相比，数组具有更好的缓存位置。


> 双向链表

尽管从链表的头节点遍历到尾节点很简单，但反过来，从后向前遍历则没那么简单。通过 给 Node 对象增加一个属性，该属性存储指向前驱节点的链接，这样就容易多了。此时向链 表插入一个节点需要更多的工作，我们需要指出该节点正确的前驱和后继。但是在从链表 中删除节点时，效率提高了，不需要再查找待删除节点的前驱节点了。

![](../img/llinkedlist.png)


